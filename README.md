# Marker API Playground

This repository is the intial testing ground and development-environment for
the new marker API.

## Get Started

```
npm install
npm start
```

will start our 'playground' environment that is used to test new features.

## Overview

The playground is a side-by-side view of a google map with a monaco editor (the
editor-component of VSCode) where typescript code using the new
marker-API can be written and executed to get a feel for the api and test
different usage-scenarios in a fast way. The contents of the editor can be
serialized into the URL for sharing.

Compiling the typescript happens in a worker via the typescript-support
already built into the monaco-editor. For execution, a wrapper emulates the
common.js environment to allow importing a predefined set of modules. Other
modules can only be imported using async imports from urls.

## Code Organization

- `/`: contains `index.html` and configuration-files
- `/scripts`: this is the place for utility scripts, mostly written in [zx][]
- `/src`: the typescript source-root. At this level, the
  playground-application entrypoint is located
- `/src/lib`: contains everything that will eventually become
  the markers-library
- `/src/editor`: contains all the source-files for editor-specific
  functionality (monaco setup etc.)
- `/examples`: contains the examples-index-page and source-files for all
  examples. The typescript-files here are packaged into examples.json by
  the `update-examples.mjs` script and should all follow the conventions for
  examples below
- `/examples/lib`: contains the typescript declaration-files used by the
  editor and referenced by the examples. Those files are generated by
  `npm run build:dts` from the library files in `src/lib`
- `/types` is for additional typescript declarations

[zx]: https://github.com/google/zx

## Writing examples

- the first line of the example has to contain a comment in the form:
  `// title: This describes what it does` - this comment will be the text
  shown in the example-index
- the example must import the marker-library modules via the `*.d.ts` files
  available in `./examples/lib/` (e.g. `import {Marker} from './lib/marker';`).
- there has to be a default export, which will be called with the
  map-instance as parameter when the script is run
- When any changes are done in the browser environment (event-listeners,
  timeouts, intervals, ...), the exported function has to return a cleanup
  function removing all those. This doesn't apply for created markers, those
  are automatically removed from the map when a new version of the script is
  executed.

# Marker API Design Decisions

## Concepts

### Attributes

Marker attributes are all the different values that make
up the marker's appearance and are generally passed on to the google maps
implementation. They are either passed to the constructor or can be set as
properties on the marker-object. Any change to a marker-attribute will
be immediately written to the marker.

- **all markers:**

  - position
  - collisionBehaviour
  - draggable
  - ...

- **pinview markers:**

  - background
  - borderColor
  - glyph
  - glyphColor
  - scale
  - ...

- **html markers:**

  - element
  - classes

- **additional attributes:** where it makes sense, we will introduce more
  attributes that control a combination of aspects in the maps-api (e.g. the
  color attribute which control all other color-attributes) or additional
  features not present in the maps api (e.g. marker shapes).

### Static and Dynamic Attributes

Every attribute can be specified either as a direct value
(e.g. `marker. color = 'green';`) or as a function, that receives a state-object and
can use that to compute the final values. For dynamic attributes the
computed values is updated with every change to the state. The state
contains information about the map (all camera parameters and current map
bounds), the marker (interaction state, map visibility, ...), other attributes
and user-specified data.


## API Surface

 - `new Marker()`
 - attributes
 - marker.setData(data);
